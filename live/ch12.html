<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
		Remove this if you use the .htaccess -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

		<title>Watson</title>

		<link rel='stylesheet' href='css/generalmedia.css'>
		<meta name="description" content="">
		<meta name="author" content="Burt">

		<meta name="viewport" content="width=device-width; initial-scale=1.0">
		<script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v4.7.4.min.js"></script>
	</head>

	<body oncontextmenu="return false;">
		<div id="wrapper">
			<!-- Header division -->

			<div id="header">
				<a href="index.html"><h3 style="margin:0; color: white;">CHAPTER 12:DIGITAL CIRCUIT DESIGN</h3></a>
			</div>
			<!-- End header -->

			<!-- Navbar division -->

			<div id="headnav">
				<table style="width: 100%" cellspacing="2" cellpadding="2">

					<tr style="background-color: #E31B23;">

						<td style="width: 25%"><a href="labs.html">LABS</a></td>

						<td style="width: 25%"><a href="documentation.html">DOCUMENTATION</a></td>

						<td style="width: 25%"><a href="tutorials.html">TUTORIALS</a></td>

						<td style="width: 25%"><a href="about.html">ABOUT</a></td>

					</tr>

				</table>

			</div><!-- End nav -->

			<div id="chapnav">
				<table style="width: 100%" cellspacing="2" cellpadding="2">

					<tr style="background-color: #E31B23;">

						<td style="width: 15%"><a href="chapters.html">CHAPTERS</a></td>

						<td style="width: 5%"><a href="ch01.html">01</a></td>

						<td style="width: 5%"><a href="ch02.html">02</a></td>

						<td style="width: 5%"><a href="ch03.html">03</a></td>

						<td style="width: 5%"><a href="ch04.html">04</a></td>

						<td style="width: 5%"><a href="ch05.html">05</a></td>

						<td style="width: 5%"><a href="ch06.html">06</a></td>

						<td style="width: 5%"><a href="ch07.html">07</a></td>

						<td style="width: 5%"><a href="ch08.html">08</a></td>

						<td style="width: 5%"><a href="ch09.html">09</a></td>

						<td style="width: 5%"><a href="ch10.html">10</a></td>

						<td style="width: 5%"><a href="ch11.html">11</a></td>

						<td style="width: 5%"><a href="ch12.html">12</a></td>

						<td style="width: 5%"><a href="ch13.html">13</a></td>

						<td style="width: 5%"><a href="ch14.html">14</a></td>

						<td style="width: 5%"><a href="ch15.html">15</a></td>

					</tr>

				</table>
				
				<!--Floating nav -->
				<style>
				div.floating-menu
				{position:fixed;z-index:200;left:1px;width:20px;top:45%;}
				div.floating-menu a, div.floating-menu h3 {display:block;margin:0 0.5em;}
				</style>
				<div class="floating-menu">
				<a href="http://www.example.com ">
					<span>
						<object width="20px" height="60px" type="image/svg+xml" data="images/left-arrow.svg">Your browser does not support SVG</object>
					</span>
				</a>
				</div>
				<!-- End floating nav -->
			</div>
			<!-- End nav -->

			<!-- Main content -->
			<p class="Section">
				12.1 Introduction
			</p>

			<p>
				In the previous chapter we saw how high-level programs can be translated into assembly language and from there be expressed in a machine language of 1’s and 0’s. We also looked at the physical characteristics of simple register-based machines, concentrating on how CPU registers and main memory storage locations could be manipulated by the various machine language instructions.
			</p>

			<p>
				This chapter examines how computer hardware can be constructed. While the details necessary to build a complete computer – even one as simple as the Watson Virtual Machine – are beyond the scope of this book, this chapter illustrates how many of the basic components of a computer, such as the addition unit and comparison circuitry, can be constructed. Surprisingly, as we will see, digital computers are based on just three simple logic circuits, or “gates” as they are called. These gates: <span class="Ital">and</span>, <span class="Ital">or</span>, and <span class="Ital">not</span>, can be interconnected in various ways to form all of the major functional components of a computer.
			</p>

			<p>
				Section 12.2 presents the fundamentals of digital logic. First, the idea of two-state devices is introduced using simple electrical circuits. The behavior of these circuits is then generalized to logic gates, which are, in turn, represented using Boolean expressions. The section concludes with a discussion of several simple circuits and their corresponding gate representations.
			</p>

			<p>
				Section 12.3 is concerned with the design of combinational circuits. Combinational circuits are constructed by interconnecting the logic gates of Section 12.2 in various ways.
			</p>

			<p>
				Section 12.4 presents another class of circuits that are also constructed from the basic logic gates. This class, called the sequential circuits, differs from combinational circuits in that they support feedback. In other words, one or more of the outputs of a sequential circuit can be fed back to that circuit as input.
			</p>

			<p>
				Section 12.5 illustrates how some of the basic components of a computer, such as main memory and portions of the Arithmetic / Logic Unit (ALU), can be implemented using the combinational and sequential circuits of Sections 12.3 and 12.4.
			</p>

			<h1>INSERT FIGURE 1</h1>

			<p class="Figure">
				Figure 12.1: Representations of switches and light bulbs
			</p>

			<p class="Section">
				12.2 Fundamentals of digital logic&nbsp;
			</p>

			<p>
				Lots of devices have two states: a voltage is high or low, a switch is open or closed, a light is on or off. There are many ways of modeling these two-state systems, some are very concrete and some are more abstract. In this section we’ll look at a number of these models, beginning with simple models that are based on mechanical switches and light bulbs, moving next to representations that use logic gates, and ending with an abstract representation that involves equations written in a type of mathematics known as Boolean algebra.
			</p>

			<p class="Section">
				12.2.1 Switches&nbsp;
			</p>

			<p>
				Our first model uses mechanical switches that can be either open or closed. These switches are similar to the electrical switches in your home. We will assume that these switches are connected to a source of power that can supply current. Light bulbs will be used to indicate the presence or absence of current. Figure 12.1 illustrates both the switches and light bulbs.
			</p>

			<p>
				The simplest circuit that can be built contains a power supply, a single switch, and a light bulb. If the switch is open, the light is off; if the switch is closed, the light is on. Figure 12.2 shows these two situations and records this information in tabular form.
			</p>
			<h1>INSERT FIGURE 12.2</h1>
			<p class="Figure">
				Figure 12.2: Open and closed switches
			</p>

			<h1>INSERT FIGURE 12.3</h1>
			<p class="Figure">
				Figure 12.3: Two switches in series – power flows only when both A and B are closed
			</p>

			<p>
				<span>We can increase the complexity of our circuit somewhat by adding a second switch between the first switch and the light bulb. Figure 12.3 illustrates the four possible configurations of this circuit: (1) both switches open, (2) the first switch open and the second closed, (3) the first switch closed and the second open, or (4) both switches closed. The circuits of Figure 12.3 are called</span> <span class="Ital">series</span> <span class="Ital">circuits</span> <span>since the two switches occur on the same “path” from the power source back to itself. In series circuits, when either or both of the switches, are open, power will not flow and the light bulb will be off. Only when both switches are closed, does power flow and the light bulb illuminates.  Said another way, if both switch A</span> <span class="Ital">and</span> <span>switch B are closed, then the light will turn on. The relationship between the states of the two switches (open or closed) and the state of the light bulb (on or off) is summarized in tabular form in Figure 12.3.</span>
			</p>

			<p>
				<span>Another type of circuit can be designed using two switches. This second type of circuit arranges the switches in parallel rather than in series. In a two-switch</span> <span class="Ital">parallel circuit</span> <span>, each of the switches is placed on a separate path between the power source and the light bulb.</span>
			</p>

			<h1>INSERT FIGURE 12.4</h1>
			<p class="Figure">
				Figure 12.4: Two switches in parallel – power flows when either A or B is closed
			</p>

			<p>
				<span>Figure 12.4 illustrates the four possible configurations of a two-switch parallel circuit. As was the case with the series circuit, there are four possible configurations of the circuit: (1) both switches open, (2) the first switch open and the second closed, (3) the first switch closed and the second open, or (4) both switches closed. When both switches are open power does not flow and the light bulb is off. However, whenever either or both of the switches are closed, power flows and the light will turn on. Said another way, if switch A</span> <span class="Ital">or</span> <span>switch B is closed, then the light will turn on.</span>
			</p>

			<p>
				More complex circuits with three or more switches are possible. In the exercises below you will develop some circuits with three switches.
			</p>

			<p class="Section">
				Exercises for Section 12.2.1
			</p>

			<ol>
				<li>
					<p>
						Draw a circuit with three switches, called A, B, and C, in <span class="Ital">series</span> <span>connected to a power supply and a light bulb. Summarize in tabular form the relationship between the states of the three switches (open or closed), and the state of the light bulb (on or off). Your table should resemble the one given in Figure 12.3, but contain eight, instead of four, rows.</span> &nbsp;
					</p>
				</li>

				<li>
					<p>
						Draw a circuit with three switches, called A, B, and C, in <span class="Ital">parallel</span> <span>connected to a power supply and a light bulb. Summarize in tabular form the relationship between the states of the three switches (open or closed), and the state of the light bulb (on or off). Your table should resemble the one given in Figure 12.4, but contain eight, instead of four, rows.</span> &nbsp;
					</p>
				</li>

				<li>
					<p>
						Given the circuit below, summarize in tabular form the relationship between the states of the three switches (open or closed), and the state of the light bulb (on or off). &nbsp;
					</p>
				</li>

				<li>
					<p>
						Suppose that a circuit contains <span class="Ital">n</span> switches. How many different combinations of values are possible for these <span class="Ital">n</span> switches? &nbsp;In other words, how many rows would a table summarizing the relationship between the switches and light bulb require?&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.2.2 Gates&nbsp;
			</p>

			<p>
				Gates are electronic versions of the mechanical switches introduced above. Some gates have multiple inputs, but all gates have a single output. Just as the switches and light bulbs of the previous examples were always in either of two states, the inputs and outputs of gates are confined to two voltage states. The voltage of every input to the gate, as well as the output from the gate, must be either high (5 volts) or low (ground). We use the symbol “1” to represent the high voltage state and “0” to represent the low voltage state.
			</p>

			<p>
				<span>There are three basic kinds of logic gates:</span> <span class="Ital">and</span> <span>gates,</span> <span class="Ital">or</span> <span>gates, and</span> <span class="Ital">not</span> <span>gates. An</span> <span class="Ital">and</span> <span>gate has two inputs and one output. The output is “1” (high) only when both inputs are “1” (high). In all other cases the output of</span> <span class="Ital">and</span> <span>is “0” (low). Figure 12.5 presents the standard symbol for an</span> <span class="Ital">and</span> <span>gate along with its definition in the form of a truth table. The inputs to the gate have been labeled “A” and “B”, while the output has been labeled “Z”.</span>
			</p>

			<p>
				<span>A</span> <span class="Bolded">truth table</span> <span>defines the meaning of a gate, or circuit, by listing every possible configuration of inputs along with the corresponding output. Traditionally, inputs are listed on the left side of the table with the output on the right. Each row of the truth table represents one configuration that the circuit can be in. Truth tables for circuits with</span> <span class="Ital">n</span> <span>inputs will always have exactly 2</span><span class="Superscript">n</span> <span>rows, one for each possible configuration of the inputs.</span>
			</p>

			<p>
				<span>Since</span> <span class="Ital">and</span> <span>has two inputs, its truth table will contain 2</span><span class="Superscript">2</span> <span>= 4 rows. The first row of the truth table of Figure 12.5 represents the situation in which both inputs to the</span> <span class="Ital">and</span> <span>gate are low. In this case the output will be low as well. The second and third rows cover the cases in which one of the inputs is high and the other is low. In line two, the first input is low and the second is high. In line three, the first input is high and the second is low. In either case, the output is low. The final row of the table represents the situation in which both inputs are high. In this case, the output will be high as well.</span>
			</p>

			<p>
				<span>The functionality of the</span> <span class="Ital">and</span> <span>gate can be implemented by the series circuit introduced in Section 12.2.1. In fact, you may have noticed that the truth table for</span> <span class="Ital">and</span> <span>is identical to the table of values given in Figure 12.3 for two switches in series, if “open” / “off” is replaced by “0” and “closed / “on” is replaced by “1”.</span>
			</p>

			<h1>INSERT FIGURE 12.5</h1>
			<p class="Figure">
				Figure 12.5: An <span class="Ital">and</span> gate
			</p>

			<h1>INSERT FIGURE 12.6</h1>
			<p class="Figure">
				Figure 12.6: An <span class="Ital">or</span> gate
			</p>

			<p>
				The reason that truth tables are called “truth tables” is that if “1” is taken to mean “true” and “0” is taken to mean “false” then the output of the table defines the circumstances under which the specified logical operation is true. For example, in common English usage, “A and B” will be true only when both A and B are true. The statement: “My cat is old and fat” is only true when the cat in question is both “old” and “fat”. If my pet cat were either young, or skinny, or both, then the statement about her would be false.
			</p>

			<p>
				The thing that is so exceedingly cool about logic gates, and the circuits that implement them, is that very simple devices, such as those presented in Section 12.2.1, can capture small parts of what humans consider “logical reasoning”. As you can well imagine, this idea caused great excitement when first discovered. We’ll have much more to say about logic and its relation to intelligent behavior in Chapter 14: Computing and Intelligence. For now, let’s return to the discussion of the basic logic gates.
			</p>

			<p>
				<span>The standard symbol for an</span> <span class="Ital">or</span> <span>gate and its definition via truth table are given in Figure 12.6. </span> <span class="Ital">Or</span> <span>gates are similar to</span> <span class="Ital">and</span> <span>gates in that they have two inputs and a single output. The output of the</span> <span class="Ital">or</span> <span>gate is “1” whenever either, or both, of the inputs are “1”. The only case in which the output of</span> <span class="Ital">or</span> <span>is “0” is when both of the inputs are “0”.</span>
			</p>

			<p>
				<span>An</span> <span class="Ital">or</span> <span>gate can be implemented by the parallel circuit of Figure 12.4. This can be seen by comparing the circuit’s table of values to the truth table of Figure 12.6 – making the necessary substitutions of “0” for &nbsp;“open” / “off” and “1” for “closed / “on”.</span>
			</p>

			<p>
				<span>You should convince yourself that the behavior of the</span> <span class="Ital">or</span> <span>gate captures the semantics of the word</span> <span class="Ital">or</span> <span>as it is commonly used. The statement: “My cat is either on the couch or under the bed.” is true if either the phrase “my cat is on the couch” is true or the phrase “my cat is under the bed” is true. The original statement is false only when neither of these phrases is true.</span>
			</p>

			<h1>INSERT FIGURE 12.7</h1>
			<p class="Figure">
				<span>Figure 12.7: A</span> <span class="Ital">not</span> <span>Gate</span>
			</p>

			<p>
				<span>The third basic logic gate is the</span> <span class="Ital">not</span> <span>gate. It has a single input and a single output. The output is the inverse of the input, as shown in the truth table in Figure 12.7. Note that this truth table consists of only two rows, rather than four as was the case with</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>. This is consistent with the claim that truth tables contain exactly 2</span><span class="Superscript">n</span> <span>rows for an</span> <span class="Ital">n</span> <span>input circuit. Since</span> <span class="Ital">not</span> <span>takes in only a single input, there are only two possible configurations that the gate can be in.</span>
			</p>

			<p>
				<span>As with</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>, the behavior of the</span> <span class="Ital">not</span> <span>gate captures the semantics of the word. If the sentence: “My cat is black.” is true, then the sentence “My cat is</span> <span class="Ital">not</span> <span>black.” would be false. And vice versa.</span>
			</p>

			<p>
				In exercise 3 of Section 12.2.1, the following circuit, which uses three switches, was presented:
			</p>

			<p>
				<span>It is natural to ask at this point what an equivalent circuit consisting of logic gates would look like. Since switches A and B are in parallel, this portion of the circuit can be represented using an</span> <span class="Ital">or</span> <span>gate. The output of that part of the circuit is in series with C, so it can be modeled with an</span> <span class="Ital">and</span> <span>gate. The logic gate circuit shown below is thus equivalent to the switch circuit given above.</span>
			</p>
			
			<div id="container1">
			<div id="tableDiv"></div></div>

			<p class="Section">
				Exercises for Section 12.2.2
			</p>

			<ol>
				<li>
					<p>
						Develop the complete truth table for the following circuit:&nbsp;
					</p>
				</li>

				<li>
					<p>
						Draw a circuit using switches, a power supply, and a light bulb for the following logic circuit:&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop the complete truth table for the circuit of problem 2.&nbsp;
					</p>
				</li>
			</ol>
			<p class="Section">
				12.2.3 Boolean algebra&nbsp;
			</p>

			<p>
				<span>The arithmetic that is used to reason about two-state systems was first developed by George Boole in 1854. </span> <span class="Bolded">Boolean algebra</span> <span>is a mathematics based on three fundamental operators:</span> <span class="Ital">and</span> <span>,</span> <span class="Ital">or</span> <span>, and</span> <span class="Ital">not</span> <span>; and the variables on which they operate. Boolean variables are binary, having only two valid states “1” (representing “true”) and “0” (representing “false”). </span>
			</p>

			<p>
				<span>The operator</span> <span class="Ital">and</span> <span>is written as a dot “</span> <span></span> <span>”,</span> <span class="Ital">or</span> <span>is written as a plus “+”, and</span> <span class="Ital">not</span> <span>is written as a horizontal bar drawn over the expression being negated. The behavior of these three Boolean operators is identical to the behavior of the corresponding logic gates. Thus, the expression “A</span> <span></span> <span>B”, meaning “A and B”, will be “1” (true) when the variables A and B are both “1” (true). The expression “A + B”, meaning “A or B”, will be true when either or both variables are true. Not A, written “ A ”, will be “0” when A is “1” and “1” when A is “0”.</span>
			</p>

			<p>
				The relationship between the Boolean operators and the fundamental logic gates is illustrated in Figure 12.8. In the illustration, the Boolean variables A and B correspond to the inputs to the circuit and the variable Z corresponds to the output.
			</p>

			<p>
				Consider the following circuit and its corresponding Boolean expression.
			</p>

			<p class="Figure">
				<span class="Bolded">Z &nbsp;= &nbsp;( A + B )  C</span>
			</p>

			<p>
				<span>We can be sure that the circuit and the expression are functionally equivalent by examining how the Boolean expression could be derived from the circuit. Since inputs A and B are fed into an</span> <span class="Ital">or</span> <span>gate in the circuit, the variables A and B are combined via the corresponding “+” operator in the Boolean expression. The output of the</span> <span class="Ital">or</span> <span>is fed into an</span> <span class="Ital">and</span> <span>gate (along with input C) in the circuit. Thus, the result of the expression “(A + B)” is combined with variable C using the “</span> <span></span> <span>” operator in the Boolean expression.</span>
			</p>

			<h1>INSERT FIGURE 12.8</h1>
			<p class="Figure">
				Figure 12.8: Boolean expressions for the three fundamental logic gates
			</p>

			<p>
				<span>As in ordinary algebra, Boolean algebra uses parentheses to indicate which operands go with which operators. The Boolean expression “A + (B</span> <span></span> <span>C)” represents a completely different circuit from “(A + B)</span> <span></span> <span>C”. In the first, B and C are fed into an</span> <span class="Ital">and</span> <span>gate, with the result being sent (along with A) into an</span> <span class="Ital">or</span> <span>gate. In the second, A and B are fed into an</span> <span class="Ital">or</span> <span>gate, with the result being combined with C via an</span> <span class="Ital">and</span> <span>gate.</span>
			</p>

			<p>
				As you may be beginning to suspect, there is a direct correspondence between Boolean expressions and logic circuits. Every logic circuit that can ever be constructed will have a corresponding Boolean expression, and every valid Boolean expression that can ever be written maps to an equivalent logic circuit. The process of converting between the two representations is quite mechanical – simply use the substitutions of Figure 12.8, being sure to parenthesize Boolean expressions in a manner that preserves which operators go with which operands.
			</p>

			<p>
				Boolean algebra provides computer scientists and engineers with a powerful tool for concisely representing circuits and reasoning about their behavior. While the details are beyond the scope of this book, Boolean algebra allows us to do things like prove that two different circuits compute the same function or find simpler (and thus less expensive) ways of implementing the functionality of a circuit.
			</p>

			<p class="Section">
				Exercises for Section 12.2.3
			</p>

			<ol>
				<li>
					<p>
						Write the Boolean expression corresponding to the following circuit.
					</p>
				</li>
				<h1>INSERT FOLLOWING CIRCUIT</h1>
				<li>
					<p>
						Write the Boolean expression corresponding to the following circuit.
					</p>
				</li>
				<h1>INSERT FOLLOWING CIRCUIT</h1>
			</ol>

			<p class="Section">
				12.2.4: Other Gates
			</p>

			<p>
				Any device, whose operation can be defined in terms of a truth table or Boolean expression, can be implemented using only the fundamental logic gates: <span class="Ital">and</span>, <span class="Ital">or</span>, and <span class="Ital">not</span>. However, a number of additional gates are usually defined, as they prove useful for practical purposes. For example, it is frequently the case that a <span class="Ital">not</span> will immediately follow an <span class="Ital">and</span> gate, like so:
			</p>

			<h1>INSERT FIGURE</h1>
			<p>
				<span>Since this is such a common occurrence, the circuit has been given a name (</span> <span class="Ital">nand</span> <span>) and a gate symbol (the</span> <span class="Ital">and</span> <span>symbol combined with the bubble from the</span> <span class="Ital">not</span> <span>symbol). Similarly,</span> <span class="Ital">not</span> <span>often follows</span> <span class="Ital">or</span> <span>, so there is a</span> <span class="Ital">nor</span> <span>gate whose symbol is the bubble from the</span> <span class="Ital">not</span> <span>attached to the</span> <span class="Ital">or</span> <span>symbol.</span>
			</p>

			<p>
				<span>Figure 12.9 illustrates both the</span> <span class="Ital">nand</span> <span>and</span> <span class="Ital">nor</span> <span>gates. Their behavior, in terms of Boolean expressions, is provided in the figure as well. It is important to remember that these gates are simply a convenience, a kind of “shorthand”, in that they allow a circuit to be constructed from fewer underlying components.</span>
			</p>

			<p>
				<span>As another example, the basic</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>gates support only two inputs, but a circuit designer will frequently need to</span> <span class="Ital">and</span> <span>or</span> <span class="Ital">or</span> <span>more than two inputs. For this reason multi-input</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>gates exist. Figure 12.10 presents the three and four input</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>gates along with their Boolean expressions. </span>
			</p>

			<h1>INSERT FIGURE 12.9</h1>
			<p class="Figure">
				Figure 12.9: <span class="Ital">Nand</span> and <span class="Ital">nor</span> gates
			</p>

			<h1>INSERT FIGURE 12.10</h1>
			<p class="Figure">
				<span>Figure 12.10: Three and four input</span> <span class="Ital">and</span> <span>and</span> <span class="Ital">or</span> <span>gates</span>
			</p>

			<p>
				While these gates are often quite convenient, remember that it is always possible to construct equivalent circuits from the underlying two-input gates. For example, the circuit:
			</p>

			<p>
				<span>represents one possible implementation of a four-input</span> <span class="Ital">or</span> <span>.</span> <span class="Footnote"><a href="#ftn1" id="body_ftn1">[1]</a></span> <span>&nbsp;The other multi-input gates can be constructed in a similar manner.</span>
			</p>

			<p>
				In addition to multi-input <span class="Ital">and</span> and <span class="Ital">or</span> gates, multi-input <span class="Ital">nand</span> and <span class="Ital">nor</span> gates can be constructed. The symbols for these gates are identical to the symbols for the multi-input <span class="Ital">and</span> and <span class="Ital">or</span> gates with the exception of a <span class="Ital">not</span> bubble attached to the output pin of each gate symbol. Their Boolean expressions are also identical to those of Figure 12.10, except that a <span class="Ital">not</span> bar appears above the right-hand side of the expression.
			</p>

			<p class="Section">
				&nbsp;
			</p>

			<p class="Section">
				Exercises for Section 12.2.4
			</p>

			<ol>
				<li>
					<p>
						Implement a 3-input <span class="Ital">and</span> <span>using 2-input</span> <span class="Ital">and</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 3-input <span class="Ital">and</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 4-input <span class="Ital">and</span> <span>using 2-input</span> <span class="Ital">and</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 4-input <span class="Ital">and</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 3-input <span class="Ital">or</span> <span>using 2-input</span> <span class="Ital">or</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 3-input <span class="Ital">or</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 4-input <span class="Ital">or</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 3-input <span class="Ital">nand</span> <span>using 2-input</span> <span class="Ital">and</span> <span>gates and single-input</span> <span class="Ital">not</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 3-input <span class="Ital">nand</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 4-input <span class="Ital">nand</span> <span>using 2-input</span> <span class="Ital">and</span> <span>gates and single-input</span> <span class="Ital">not</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 4-input <span class="Ital">nand</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 3-input <span class="Ital">nor</span> <span>using 2-input</span> <span class="Ital">or</span> <span>gates and single-input</span> <span class="Ital">not</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 3-input <span class="Ital">nor</span> <span>gate.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Implement a 4-input <span class="Ital">nor</span> <span>using 2-input</span> <span class="Ital">or</span> <span>gates and single-input</span> <span class="Ital">not</span> <span>gates.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Develop a complete truth table for the 4-input <span class="Ital">nor</span> gate.&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.3 &nbsp;Combinational circuits
			</p>

			<p>
				<span>Combinational circuits are digital circuits that do not involve any kind of feedback. In other words, the output of a combinational circuit cannot be fed back into that circuit as input. In this section we’ll talk about a number of combinational circuits that are used in the construction of digital computers. These circuits include comparators, adders, decoders, encoders, multiplexers, and demultiplexers. First, we begin with a relatively simply circuit, the “exclusive or” or</span> <span class="Ital">xor</span> <span>.</span>
			</p>

			<p class="Section">
				12.3.1 &nbsp;The “exclusive or” circuit
			</p>

			<p>
				<span>An “exclusive or”, or</span> <span class="Ital">xor</span> <span>, has two inputs and a single output. Its behavior is defined by the following truth table, where the inputs are labeled “A” and “B” and the output is labeled “Z”.</span>
			</p>

			<h1>INSERT XOR</h1>

			<p>
				<span>Like the standard two-input</span> <span class="Ital">or</span> <span>, the</span> <span class="Ital">xor</span> <span>produces a “1” (true) when either of its inputs are “1”, and a “0” (false) when both of its inputs are “0”. The difference between</span> <span class="Ital">or</span> <span>and</span> <span class="Ital">xor</span> <span>appears in the case when both inputs are “1”. The standard</span> <span class="Ital">or</span> <span>produces a “1” in this case. The</span> <span class="Ital">xor</span> <span>generates a “0”. In other words, the “exclusive or” outputs a “1” when either,</span> <span class="Ital">but not both</span> <span>, of its inputs are “1”. </span>
			</p>

			<p>
				<span>English does not contain a unique word for expressing the idea of</span> <span class="Ital">xor</span> <span>– the word “or” does double duty for both its “inclusive” and “exclusive” forms. However, one can usually tell from the context of a sentence which form is intended. For example, if you tell a child “you can have candy or popcorn” the intended meaning is exclusive or – either candy or popcorn, but not both. On the other hand, if a friend says “I’d be happy winning</span> <span>either the Porsche or the Mercedes” the intended meaning is inclusive or – you would certainly not expect your friend to become unhappy if he won both cars.</span>
			</p>

			<p>
				<span>Now that we understand the behavior of</span> <span class="Ital">xor</span> <span>in terms of its inputs and outputs, we can turn our attention to the problem of designing a circuit with its behavior.</span>
			</p>

			<p>
				How are we to begin?
			</p>

			<p>
				<span>One approach that often gets you moving in the right direction is to examine the truth table to determine the various circumstances under which the circuit must produce a “1”. In the case of</span> <span class="Ital">xor</span> <span>there are two such cases, one in which input A is “0” and input B is “1”; and another in which input A is “1” and input B is “0”. Once these cases have been identified, we proceed by designing “sub-circuits” that will produce “1” in each of the required cases. The final step is to combine the sub-circuits together using an</span> <span class="Ital">or</span> <span>gate. This is necessary because the main circuit would be true under any of the cases in which the sub-circuits generate a “1”.</span>
			</p>

			<p>
				The following sub-circuit will generate a “1” when input A is “0” and input B is “1”.
			</p>

			<h1>INSERT SUB-CIRCUIT</h1>

			<p>
				<span>It works by negating A and feeding that result (together with B) into an</span> <span class="Ital">and</span> <span>gate.  &nbsp;Since both of the inputs to an</span> <span class="Ital">and</span> <span>must be “1” for it to produce a “1”, the original value of A must be “0”, while the value of B must be “1”. Under all other circumstances this sub-circuit produces “0”. Thus, this circuit successfully captures the meaning of line two of the</span> <span class="Ital">xor</span> <span>truth table.</span>
			</p>

			<p>
				<span>A sub-circuit to implement line three of the</span> <span class="Ital">xor</span> <span>truth table can be constructed similarly.</span>
			</p>

			<p>
				<span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="Bolded">A</span> <span></span> <span class="Bolded">B</span>
			</p>

			<p>
				This circuit generates a “1” whenever input A is “1” and the input B is “0”. Under all other circumstances it produces a “0”.
			</p>

			<p>
				<span>Figure 12.11 illustrates a complete</span> <span class="Ital">xor</span> <span>circuit, which contains the two sub-circuits joined together by an</span> <span class="Ital">or</span> <span>gate. This is reasonable, since the</span> <span class="Ital">xor</span> <span>can be true either by way of the first sub-circuit or the second. Note that due to the manner in which the two sub-circuits were constructed, it is impossible for both of them to be true at the same time.</span>
			</p>

			<h1>INSERT FIGURE 12.11</h1>
			<p class="Figure">
				Figure 12.11: An implementation of <span class="Ital">xor</span>
			</p>

			<p>
				<span>A new feature introduced in this circuit diagram is the connection point. Each of the two sub-circuits making up the</span> <span class="Ital">xor</span> <span>requires access to both inputs. Hence, the wires that represented these inputs had to be “split” in some way. We indicate a branch, or connection, point in a circuit diagram by a dot. Connection points allow a wire to be “split” so that its current state can “flow” to multiple destinations.  Here is what a connection point looks like graphically.</span>
			</p>

			<p>
				<span>The pin on the left is the input to the connection point, or connector. The top, right, and bottom pins are the outputs. Hence, this connector splits the input wire three ways. In the</span> <span class="Ital">xor</span> <span>circuit diagram a two-way, rather than three-way split was required, so one of the output pins is not drawn.</span>
			</p>

			<p>
				<span>Connection points should not be confused with wires that just happen to cross one another by chance. In such a case there is</span> <span class="Ital">no</span> <span>connection between the wires, so their signals do not interfere in any way. (Think of the wires as insulated and just lying across one another.) &nbsp;Wires that cross but are not connect are represented graphically in the following way:</span>
			</p>

			<p>
				<span>You should convince yourself that the circuit of Figure 12.11 does indeed implement the truth table for</span> <span class="Ital">xor</span> <span>. However, you should not come away from this discussion thinking that the circuit of Figure 12.11 is the only way (or even the most efficient way) to implement the</span> <span class="Ital">xor</span> <span>behavior. The approach to circuit design of identifying the lines of the truth table that generate a “1”, implementing sub-circuits to generate a “1” only under those circumstances, and then connecting all of the sub-circuits together via an</span> <span class="Ital">or</span> <span>, works. But, it frequently results in circuits that are more complex than really necessary. </span>
			</p>

			<span>For example, our implementation of</span> <span class="Ital">xor</span> <span>requires five gates (not counting connectors). An implementation that requires only four gates can be developed from the Boolean expression Z = (A + B)</span> <span></span> <span>(A</span> <span></span> <span>B).</span>

			<p class="Section">
				Exercises for Section 12.3.1
			</p>

			<ol>
				<li>
					<p>
						Draw the circuit diagram for the implementation of <span class="Ital">xor</span> <span>given by the Boolean expression: Z = (A + B)</span> <span></span> <span>(A</span> <span></span> <span>B)</span>&nbsp;
				</li>

				<li>
					<p>
						To ensure that the circuit of problem 1 does, in fact, implementation the behavior of <span class="Ital">xor</span> <span>, give the circuit’s truth table.</span>&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.3.2 Comparators&nbsp;
			</p>

			<p>
				The purpose of a comparator is to examine two input values to determine whether a particular condition is satisfied. If the inputs satisfy the condition, the comparator generates a “1” (true). If the inputs do not satisfy the condition, the comparator generates a “0” (false).
			</p>

			<p>
				The most common type of comparator is the “comparator for equality”. This type of comparator determines whether two input values are identical. If the values are the same, the comparator generates a “1” (true). If the input values are different, the comparator generates a “0” (false).
			</p>

			<p>
				Comparators come in different sizes, based on the width of their inputs. The simplest comparator is the one-bit comparator for equality. This circuit takes in two single-bit numbers and generates a “1” if they are equal and a “0” otherwise. Here is the truth table for the one-bit comparator for equality. The inputs are labeled “A” and “B”. The output is labeled “Z”.
			</p>

			<h1>INSERT THE THING</h1>

			<p>
				<span>In order to implement a circuit with this behavior, we first note the lines of the truth table that generate a “1”. These are lines one and four. Let’s look first at line four. This line of the table says that Z should be “1” when both A and B are “1”. Implementing a circuit that will generate “1” under this circumstance, and no other, is trivial since the two-input</span> <span class="Ital">and</span> <span>gate already does exactly what we want. </span>
			</p>

			<p>
				<span>Producing a “sub-circuit” for line one of the table isn’t really that difficult either. In order to have a sub-circuit that generates “1” when both inputs are “0”, simply invert, or not, each of the inputs and send the results into an</span> <span class="Ital">and</span> <span>gate, like so:</span>
			</p>

			<p>
				This sub-circuit will produce a “1” only when both of its inputs are “0”.
			</p>

			<h1>INSERT SUB-CIRCUIT</h1>
			<h1>INSERT FIGURE 12.12</h1>
			<p class="Figure">
				Figure 12.12: An implementation of the one-bit comparator for equality
			</p>

			<p>
				<span>Combining the two sub-circuits via an</span> <span class="Ital">or</span> <span>gate gives a complete implementation of the one-bit comparator for equality. The circuit is illustrated in Figure 12.12</span>
			</p>

			<p>
				The design for the one-bit comparator for equality can be extended to multi-bit numbers. The two-bit comparator for equality has the following truth table:
			</p>

			<h1>INSERT TWO-BIT COMPARATOR</h1>

			<p>
				<span>This table consists of 16 rows, since it has four input bits. (Remember, the number of rows of a truth table is always 2</span><span class="Superscript">n</span> <span>where</span> <span class="Ital">n</span> <span>is the number of input bits.) &nbsp;In the table, A</span><span class="Subscript">0</span> <span>represents the low-order bit of input A and A</span><span class="Subscript">1</span> <span>represents the high-order bit of A. Likewise, B</span><span class="Subscript">0</span> <span>is the low-order bit of B and B</span><span class="Subscript">1</span> <span>is the high-order bit. Hence, the first row of the table represents inputs of A = 00</span><span class="Subscript">two</span> <span>and B = 00</span><span class="Subscript">two</span> <span>, which are equal, so the output, Z, is “1” (true). Likewise, the second row of the table represents A = 00</span><span class="Subscript">two</span> <span>and B = 01</span><span class="Subscript">two</span> <span>, which are not equal, so the output, Z, is “0” (false).</span>
			</p>

			<p>
				To get a clearer idea of what this circuit does, let’s examine only those rows of the table in which the output is “1” (true). There are four cases in which the two-bit comparator for equality generates a “1”. They are:
			</p>

			<h1>INSERT CASES</h1>
			<p>
				<span>The first row corresponds to the case where both A and B are zero (00</span><span class="Subscript">two</span> <span>). The second row captures the case where both inputs are one (01</span><span class="Subscript">two</span> <span>), the third where the inputs are two (10</span><span class="Subscript">two</span> <span>), and the fourth where they are three (11</span><span class="Subscript">two</span> <span>).</span>
			</p>

			<p>
				How can we build a circuit with this behavior?
			</p>

			<p>
				<span>In the previous examples we built sub-circuits to handle each case in which the main circuit was to produce “1”. We then connected the sub-circuits together using an</span> <span class="Ital">or</span> <span>gate. Because the present circuit is a multi-bit version of a circuit we have already constructed, we’ll take a different approach to the circuit design problem.</span>
			</p>

			<p>
				When attempting to construct a multi-bit version of a single-bit circuit, it is best to approach the problem by looking for ways in which single-bit versions of the circuit can be interconnected to form the multi-bit circuit.
			</p>

			<p>
				<span>A careful inspection of the above table will show that a “1” should be generated whenever the low-order bits of both inputs (A</span><span class="Subscript">0</span> <span>and B</span><span class="Subscript">0</span> <span>) are equal</span> <span class="Ital">and</span> <span>the high-order bits of the inputs (A</span><span class="Subscript">1</span> <span>and B</span><span class="Subscript">1</span> <span>) are equal as well. Hence, routing inputs A</span><span class="Subscript">0</span> <span>and B</span><span class="Subscript">0</span> <span>into a one-bit comparator for equality; and inputs A</span><span class="Subscript">1</span> <span>and B</span><span class="Subscript">1</span> <span>into a separate one-bit comparator for</span> <span>equality, then sending both of these results into an</span> <span class="Ital">and</span> <span>gate, will produce a circuit with the desired behavior. This circuit is outlined below:</span>
			</p>

			<h1>INSERT ONE-BIT COMPARATOR</h1>

			<p>
				The circuit is based on the idea that two-bit numbers are equal if both their low-order and high-order bits are identical. An actual implementation of the circuit would require that the boxes marked “one-bit comparator” be replaced with comparator circuitry along the lines of that shown in Figure 12.12. You are asked to do precisely this in one of the exercises at the end of this section.
			</p>

			<p>
				In addition to comparators for equality, comparators for other conditions, such as “less than” and “greater than”, can be constructed. While most of the details are left as exercises, I’ll get you started by giving you this truth table for the one-bit comparator for “less than” (i.e., “A &lt; B”).
			</p>

			<h1>INSERT TRUTH TABLE</h1>

			<p class="Section">
				Exercises for Section 12.3.2
			</p>

			<ol>
				<li>
					<p>
						Construct a two-bit comparator for equality using the outline of the circuit provided in this section.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Construct a one-bit comparator for less than. Also, provide a truth table and Boolean equation for the circuit.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Construct a two-bit comparator for less than. Also, provide a truth table and Boolean equation for the circuit. &nbsp;HINT: For two-bit numbers A and B, A is less than B when&nbsp;
					</p>
				</li>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1) the high-order bit of A is less than the high-order bit of B
				</p>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or &nbsp; &nbsp;
				</p>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (2.1) the high-order bits of A and B are identical
				</p>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and &nbsp;
				</p>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (2.2) the low-order bit of A is less than the low-order bit of B
				</p>

				<p>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				</p>

				<li>
					<p>
						Construct a one-bit comparator for greater than. Also, provide a truth table and Boolean equation for the circuit.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Construct a two-bit comparator for greater than. Also, provide a truth table and Boolean equation for the circuit.&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.3.3 Adders&nbsp;
			</p>

			<p>
				An “adder”, as its name implies, is a circuit for adding binary numbers. In Chapter 11 (Section 11.4.1.3) we studied binary arithmetic, including binary addition. As you may recall from that discussion, the addition of two single-bit binary numbers can be defined by a table such as:
			</p>

			<h1>INSERT TABLE</h1>
			<p>
				<span>where “A” and “B” represent the two single-bit inputs, “S” represents the sum of those inputs, and “C” represents a possible carry. The first line of the table illustrates “0 + 0” equals “0”. Lines two and three correspond to “0 + 1” and “1 + 0” both of which equal “1”. The last line of the table represents “1 + 1” which equals two (10</span><span class="Subscript">two</span> <span>). This value is represented by placing a “0” in S, the sum, and a “1” in C, the carry.</span>
			</p>

			<p>
				<span>A circuit to implement the behavior of this table will need two inputs (one for each of the single-bit numbers) and two outputs (one for the sum and one for the carry). Constructing such a circuit is fairly straightforward. Notice that the values in the S column correspond to an exclusive or,</span> <span class="Ital">xor</span> <span>, of the two inputs, while the values in the C column correspond to an</span> <span class="Ital">and</span> <span>of both inputs. The circuit can thus be constructed from these two sub-circuits as illustrated in Figure 12.13.</span>
			</p>

			<h1>INSERT FIGURE 12.13</h1>

			<p class="Figure">
				Figure 12.13: An implementation of a “half adder”
			</p>

			<p>
				<span>This circuit is called a “half adder”. While a half</span> <span>adder does add two single-bit numbers and can generate a carry, it has no provision for a carry</span> <span class="Ital">input</span> <span>into the circuit. Recall from our discussion of binary addition that when adding two multi-bit binary numbers one works column by column from right to left making sure that the carry bit from the previous column is added into the current column. Here is an illustration of this process on six and seven, represented as four-bit unsigned binary numbers.</span>
			</p>

			<h1>INSERT ILLUSTRATION</h1>

			<p>
				A half adder could be used to add the right-most (low-order) bits of the two numbers, but it is not general enough to add the digits of an arbitrary column, since it does not support a carry as input.
			</p>

			<p>
				<span>A “full adder” overcomes this limitation of the half adder by allowing a carry to be fed into the circuit along with a bit from each of the numbers to be added. Thus, a full adder will have three inputs: the two bits being added plus the carry in. Only two output bits, the “sum” and “carry out”, are needed because the largest result that can be produced by the circuit will be three (11</span><span class="Subscript">two</span> <span>). This occurs when all three inputs are set to “1”. Here is a complete truth table for a full adder. The inputs have been labeled “C</span><span class="Subscript">in</span> <span>”, “A”, and “B”; the outputs “C</span><span class="Subscript">out</span> <span>” and “S”.</span>
			</p>

			<h1>INSERT TABLE</h1>
			<p>
				Designing a circuit to implement this behavior “from scratch” would be challenging. However, through careful observation and the use of two half adders, the job is manageable. Since we’ll be using half adders to build the full adder, our circuit diagram will be simpler if we imagine the half adder encapsulated into a “black box”, as shown below:
			</p>

			<h1>INSERT FIGURE 12.14</h1>
			<p class="Figure">
				Figure 12.14: A full adder implemented using two half adders
			</p>

			<p>
				<span>The trick to building a full adder is to think of the sum of the three terms, A + B +C</span><span class="Subscript">in</span> <span>, as a sequence of two sums associated left to right: ( A + B ) + C</span><span class="Subscript">in</span> <span>. One half adder will be used to compute the sum A&nbsp;+&nbsp;B. The “sum” bit output by this half adder, along with C</span><span class="Subscript">in</span> <span>, will be fed as input into a second half adder. The “sum” bit produced by the second half adder will serve as the “sum” bit of the full adder. The “carry out” bit of the full adder is produced by routing the “carry out” bits of both half adders into an</span> <span class="Ital">or</span> <span>gate.</span>
			</p>

			<p>
				<span>Figure 12.14 illustrates the full adder in outline form. Development of a complete implementation of the full adder using only</span> <span class="Ital">and</span> <span>,</span> <span class="Ital">or</span> <span>, and</span> <span class="Ital">not</span> <span>gates is left as an exercise. You should also be sure to verify that this circuit does, in fact, generate the truth table for binary addition.</span>
			</p>

			<p>
				Just as we encapsulated the half adder, we can encapsulate the single-bit full adder into a black box.
			</p>

			<p>
				<span>This representation looks a little different than the circuit of Figure 12.14 because it has been rotated clockwise 90</span> <span></span> <span>to make the following diagram easier to read. Be assured, however, that the inputs, outputs, behavior, and internal details of the circuit remain unchanged.</span>
			</p>

			<h1>INSERT FIGURE 12.15</h1>

			<p class="Figure">
				Figure 12.15: An implementation for a four-bit adder using four one-bit adders
			</p>

			<p>
				Multi-bit adders can be implemented as a chain of single-bit full adders where the “carry out” of each adder is routed to the “carry in” of the adder immediately to its left. Under this scheme each full adder is essentially responsible for adding a single bit of each of the two input numbers, plus the carry bit generated by the adder immediately to its right. The “carry in” for the rightmost adder is permanently set to 0. The “carry out” of the leftmost adder indicates whether or not addition of the inputs produces an overflow.
			</p>

			<p>
				<span>Figure 12.15 illustrates a four-bit adder constructed from four single-bit adders. In this example, input A holds the number six (0110</span><span class="Subscript">two</span> <span>) while input B holds seven (0111</span><span class="Subscript">two</span> <span>). </span> <span>The result of this addition operation is the four-bit unsigned number 1101</span><span class="Subscript">two</span> <span>, or thirteen, with a carry (overflow) of zero.</span>
			</p>

			<p class="Section">
				Exercises for Section 12.3.3
			</p>

			<ol>
				<li>
					<p>
						Draw the complete circuit for a single-bit full adder using only gates, wires, and connectors.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Draw the complete circuit for a two-bit full adder using only gates, wires, and connectors.&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.3.4</span>&nbsp;Decoders and Encoders&nbsp;
			</p>

			<p>
				<span>A decoder is a type of circuit that takes in a number (in unsigned binary form) and generates a “1” (high) on the output line that corresponds to the input number. All other output lines are set to “0” (low). For example, given an input of 00</span><span class="Subscript">two</span> <span>, a “1” would be generated on output line zero. Likewise, given 01</span><span class="Subscript">two</span> <span>as input, a “1” would be placed on output line one. Decoders, as we will see in Section 12.5, form an integral part of memory and register addressing circuitry.</span>
			</p>

			<p>
				<span>Every decoder with</span> <span class="Ital">n</span> <span>input lines will have exactly 2</span><span class="Superscript">n</span> <span>output lines. So, a two-to-four decoder will have two input lines and four output lines, while a three-to-eight decoder will have three input lines and eight output lines. Both the input and output lines of decoders are numbered, with the</span> <span class="Ital">n</span> <span>inputs ranging from 0 to</span> <span class="Ital">n</span> <span>-1, and the 2</span><span class="Superscript">n</span> <span>outputs ranging from 0 to 2</span><span class="Superscript">n</span> <span>-1. </span>
			</p>

			<p>
				Here is the truth table for a three-to-eight decoder.
			</p>

			<h1>INSERT TRUTH TABLE</h1>

			<p>
				<span>The inputs are labeled A</span><span class="Subscript">0</span> <span>to A</span><span class="Subscript">2</span> <span>and represent the bits of a three-bit unsigned binary number. The outputs are labeled D</span><span class="Subscript">0</span> <span>through D</span><span class="Subscript">7</span> <span>. As the table shows, an input number (such as 110</span><span class="Subscript">two</span> <span>= six) results in the corresponding data line (D</span><span class="Subscript">6</span> <span>in this case) being set to “1”, with all other lines held at “0”.</span>
			</p>

			<p>
				<span>Figure 12.16 illustrates an implementation of a three-to-eight decoder. The circuit diagram uses eight three-input</span> <span class="Ital">and</span> <span>gates – one for each data line, together with a total of three</span> <span class="Ital">not</span> <span>gates. If you don’t happen to have access to three-input type</span> <span class="Ital">and</span> <span>gates, remember that they can easily be constructed from two standard two-input</span> <span class="Ital">and</span> <span>gates.</span>
			</p>

			<p>
				<span>Carefully tracing the lines in the circuit diagram, we see that all three of the inputs to the D</span><span class="Subscript">0</span> <span class="Ital">and</span> <span>gate are negated. Thus, when inputs A</span><span class="Subscript">2</span> <span>, A</span><span class="Subscript">1</span> <span>, and A</span><span class="Subscript">0</span> <span>each have a value of “0”, D</span><span class="Subscript">0</span> <span>’s three-input</span> <span class="Ital">and</span> <span>gate receives three “1’s” (</span> <span class="Ital">not</span> <span>A</span><span class="Subscript">2</span> <span>,</span> <span class="Ital">not</span> <span>A</span><span class="Subscript">1</span> <span>, and</span> <span class="Ital">not</span> <span>A</span><span class="Subscript">0</span> <span>) and generates a “1”. The result is that a “1” (high) is placed on output line zero when the number 000</span><span class="Subscript">two</span> <span>is given as input to the circuit. </span>
			</p>

			<h1>INSERT FIGURE 12.16</h1>
			<p class="Figure">
				Figure 12.16: An implementation of a three-to-eight decoder
			</p>

			<p>
				<span>Moving on to the</span> <span class="Ital">and</span> <span>gate for D</span><span class="Subscript">1</span> <span>, we note that two of the three inputs (A</span><span class="Subscript">2</span> <span>and A</span><span class="Subscript">1</span> <span>) are negated, but the third input A</span><span class="Subscript">0</span> <span>is not. Thus, when inputs A</span><span class="Subscript">2</span> <span>and A</span><span class="Subscript">1</span> <span>are “0”, but A</span><span class="Subscript">0</span> <span>is “1” (corresponding to the input number 001</span><span class="Subscript">two</span> <span>or one) the</span> <span class="Ital">and</span> <span>gate will receive three “1’s” and generate a “1” on line D</span><span class="Subscript">1</span> <span>. Skipping ahead to the final case, we see that the three-input</span> <span class="Ital">and</span> <span>gate for D</span><span class="Subscript">7</span> <span>receives all of its inputs directly from A</span><span class="Subscript">2</span> <span>, A</span><span class="Subscript">1</span> <span>, and A</span><span class="Subscript">0</span> <span>without negation. Thus, when A</span><span class="Subscript">2</span> <span>, A</span><span class="Subscript">1</span> <span>, and A</span><span class="Subscript">0</span> <span>each contain “1”(corresponding to the number 111</span><span class="Subscript">two</span> <span>or seven) the gate will generate a “1” on data line D</span><span class="Subscript">7</span> <span>. The other cases are handled in a similar manner.</span>
			</p>

			<p>
				The three-to-eight decoder of Figure 12.16 may be encapsulated using a “black box” such as:
			</p>

			<h1>INSERT BLACK BOX</h1>
			<p>
				In general, since an <span class="Ital">n</span> input decoder will always have 2 <span class="Ital">n</span> outputs, its “black box” can be expressed in the following manner:
			</p>

			<h1>INSERT BLACK BOX</h1>
			<p>
				The symbol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;, along with a number or variable, is frequently used as a shorthand in circuit design to represent the indicated number of lines without actually drawing them. Since modern computers are based on 32-bit words, this compact representation is very important.
			</p>

			<p>
				<span>It is natural to wonder at this point if there is a circuit that does the exact opposite of a decoder. In other words, is there a circuit with 2</span><span class="Superscript">n</span> <span>input lines, only one of which can be high at any point in time, that produces as output the</span> <span class="Ital">n</span> <span>bit binary number corresponding to the raised input line? &nbsp;The answer is “yes”. Such a circuit is called an “encoder”.</span>
			</p>

			<p>
				A four-to-two encoder is defined by the following truth table.
			</p>

			<h1>INSERT TRUTH TABLE</h1>
			<p>
				Note that twelve of the sixteen rows of the truth table are “grayed out”. These rows represent input configurations that are disallowed because either no input line is high, or multiple input lines are high. Thus, in these cases, there is no single high input line for the circuit to return the corresponding binary number of.
			</p>

			<p>
				<span>How are we to deal with these “undefined” configurations when constructing the corresponding circuit? &nbsp;One way is to simply ignore the disallowed input configurations. This approach will work fine as long as we can be</span> <span class="Ital">sure</span> <span>that the illegal states can never occur.</span>
			</p>

			<h1>INSERT FIGURE 12.17</h1>
			<p class="Figure">
				Figure 12.17: An implementation of an eight-to-three encoder
			</p>

			<p>
				<span>Figure 12.17 presents an implementation of an eight-to-three encoder that assumes disallowed states will never be encountered. The circuit works fine as long as we respect this limitation. For example, placing a “1” on line D</span><span class="Subscript">6</span> <span>, while holding all other lines low, causes the number 110</span><span class="Subscript">two</span> <span>, or six, to be generated. An invalid configuration of inputs generates an erroneous output. For example, setting both D</span><span class="Subscript">1</span> <span>and D</span><span class="Subscript">2</span> <span>to“1” causes the circuit to output 011</span><span class="Subscript">two</span> <span>, or three. </span>
			</p>

			<p>
				<span>One “odd” feature of this circuit is that input line D</span><span class="Subscript">0</span> <span>is not connected to anything – it is, in a sense, ignored. Although this may seem strange at first, it is precisely what we want the circuit to do. Setting line D</span><span class="Subscript">0</span> <span>to “1” (and all other input lines to “0”) is supposed to cause all of the output lines to be set to “0”, so as to represent the number 000</span><span class="Subscript">two</span> <span>, or zero.</span>
			</p>

			<p>
				<span>The truth table for the eight-to-three encoder would be similar to the one shown above for the four-to-two encoder. However, in the case of the eight-to-three encoder, the full truth table would consist of 256 rows, since it has eight input lines and thus 2</span><span class="Superscript">8</span> <span>, or 256, possible input configurations. All but eight of these input configurations would be disallowed. In order for the circuit’s truth table to fit on a page, only the “allowed” rows are presented below.</span>
			</p>

			<h1>INSERT ALLOWED ROWS</h1>

			<p>
				As you can see, this truth table is the exact inverse of the table for the three-to-eight decoder that was presented earlier.
			</p>

			<p>
				The eight-to-three encoder can be encapsulated into a “black box” similar to the following:
			</p>

			<h1>INSERT BLACK BOX</h1>
			<p>
				<span>In general, a 2</span><span class="Superscript">n</span> <span>to</span> <span class="Ital">n</span> <span>encoder can be drawn as:</span>
			</p>
			<h1>INSERT CONVERTER</h1>

			<p class="Section">
				Exercises for Section 12.3.4
			</p>

			<ol>
				<li>
					<p>
						Draw a complete implementation of a two-to-four decoder using only gates, connectors, and wires.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Draw a complete implementation of a four-to-two encoder using only gates, connectors, and wires. You may assume disallowed input configurations will never occur.&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.3.5 Multiplexers and demultiplexers&nbsp;
			</p>

			<p>
				<span>Multiplexers are circuits that are used to transfer the contents of an input data line to an output line based on the value of one or more input selector lines. While that definition sounds a bit intimidating, multiplexers really aren’t that complex. Essentially, a multiplexer is a kind of switch. It has two types of inputs, data lines and selector lines, and a single output line. The purpose of a multiplexer is to transfer the contents of</span> <span class="Ital">one</span> <span>of the input lines to the circuit’s sole output line. The values placed on the selector lines determine which data line will have its contents echoed to the output line. Thus, the selector lines allow the multiplexer circuit to switch its “attention” between the various input data lines when determining the value to be output.</span>
			</p>

			<p>
				<span>Generally, a multiplexer, or MUX</span> <span class="Footnote"><a href="#ftn2" id="body_ftn2">[2]</a></span> <span>, will have 2</span><span class="Superscript">n</span> <span>data lines for</span> <span class="Ital">n</span> <span>selector lines. The data lines are numbered 0 to 2</span><span class="Superscript">n</span> <span>– 1, and the selector lines are numbered 0 to</span> <span class="Ital">n</span> <span>– 1. The bit pattern placed on the selector lines, when interpreted as an unsigned binary number, determines the active data line.  Multiplexers are often referred to in terms of their number of data lines. So, an eight-input MUX will have eight data lines and three selector lines, while a two-input MUX will have two data lines and a single selector line. Remember that regardless of the number of input data and selector lines, every MUX has only one output line.</span>
			</p>

			<p>
				<span>Figure 12.18 presents an implementation of a two-input multiplexer. It has two data lines, one selector line, and a single output. When the selector line, S, is set to “0”, the current value of D</span><span class="Subscript">0</span> <span>(either a “1” or a “0”) becomes the output of the circuit, regardless of the value of line D</span><span class="Subscript">1</span> <span>. The circuit is, in a sense, “listening” to D</span><span class="Subscript">0</span> <span>and “ignoring” D</span><span class="Subscript">1</span> <span>. When S is “1”, the opposite situation exists. The output of the multiplexer becomes the current value of D</span><span class="Subscript">1</span> <span>, and D</span><span class="Subscript">0</span> <span>is ignored.</span>
			</p>

			<h1>INSERT FIGURE 12.18</h1>
			<p class="Figure">
				Figure 12.18: An implementation of a two-input multiplexer.
			</p>

			<p>
				The behavior of the two-input multiplexer is summarized in the following truth table.
			</p>

			<h1>INSERT TRUTH TABLE</h1>

			<p>
				<span>Figure 12.19 illustrates a somewhat more complex multiplexer, a four-input MUX. The four-input MUX has two selector lines, four data lines, and a single output line. Placing a “0” on both S</span><span class="Subscript">1</span> <span>and S</span><span class="Subscript">0</span> <span>, corresponding to 00</span><span class="Subscript">two</span> <span>, or zero, causes the value of D</span><span class="Subscript">0</span> <span>to be sent to the output line. Setting S</span><span class="Subscript">1</span> <span>to “0” and S</span><span class="Subscript">0</span> <span>to “1”, corresponding to 01</span><span class="Subscript">two</span> <span>, or one, causes D</span><span class="Subscript">1</span> <span>to be the active line. Likewise, S</span><span class="Subscript">1</span> <span>= “1” and S</span><span class="Subscript">0</span> <span>= “0”, meaning 10</span><span class="Subscript">two</span> <span>, or two, focuses attention on D</span><span class="Subscript">2</span> <span>. Finally, S</span><span class="Subscript">1</span> <span>= “1” and S</span><span class="Subscript">0</span> <span>= “1”, meaning 11</span><span class="Subscript">two</span> <span>, or three, causes the D</span><span class="Subscript">3</span> <span>input to be transferred to the output line.</span>
			</p>
			<h1>INSERT FIGURE 12.19</h1>

			<p class="Figure">
				Figure 12.19: An implementation of a four-input multiplexer
			</p>

			<p>
				<span>An inspection of the circuit diagram for the four-input multiplexer of Figure 12.19 reveals that it contains four three-input</span> <span class="Ital">and</span> <span>gates, two single-input</span> <span class="Ital">not</span> <span>gates, and one four-input</span> <span class="Ital">or</span> <span>gate. Each</span> <span class="Ital">and</span> <span>has one of the data lines running into it, plus two selector signals. Some of the selector signals have been routed directly from the selector input lines, while others have been negated before being sent on to the</span> <span class="Ital">and</span> <span>gates. The outputs of all four of the</span> <span class="Ital">and</span> <span>gates are routed into the four-input</span> <span class="Ital">or</span> <span>. The output of this</span> <span class="Ital">or</span> <span>becomes the output of the multiplexer circuit. If any one of the</span> <span class="Ital">and</span> <span>gates generate a “1”, the circuit will output a “1”. If all of the</span> <span class="Ital">and</span> <span>gates produce “0”, the circuit will output a “0”.</span>
			</p>

			<p>
				<span>In order to better understand the behavior of this multiplexer, let’s examine the conditions under which each of the</span> <span class="Ital">and</span> <span>gates could fire. A three-input</span> <span class="Ital">and</span> <span>gate can produce a “1” only if all of its inputs are “1”. Thus, the two selector signals and the data value reaching the</span> <span class="Ital">and</span> <span>gate must be “1” for that gate to generate a “1”.</span>
			</p>

			<p>
				<span>The selector signals reaching the gate that is connected to D</span><span class="Subscript">0</span> <span>are</span> <span class="Ital">not</span> <span>S</span><span class="Subscript">1</span> <span>and</span> <span class="Ital">not</span> <span>S</span><span class="Subscript">0</span> <span>. This gate can produce a “1” only when S</span><span class="Subscript">1</span> <span>= “0”, S</span><span class="Subscript">0</span> <span>= “0” and D</span><span class="Subscript">0</span> <span>= “1”. Under any other circumstances, such as a D</span><span class="Subscript">0</span> <span>of “0”, or either S</span><span class="Subscript">1</span> <span>or S</span><span class="Subscript">0</span> <span>being set to “1”, this</span> <span class="Ital">and</span> <span>gate produces a “0”. Hence, this part of the circuit faithfully “echoes” the value of D</span><span class="Subscript">0</span> <span>when the S</span><span class="Subscript">1</span> <span>,S</span><span class="Subscript">0</span> <span>bit pattern is “00”. Just as importantly, this</span> <span class="Ital">and</span> <span>gate stays low when the selector bit pattern is not “00”, regardless of the value of D</span><span class="Subscript">0</span> <span>.</span>
			</p>

			<p>
				<span>The other</span> <span class="Ital">and</span> <span>gates act in a similar manner. The gate for D</span><span class="Subscript">1</span> <span>is attached to</span> <span class="Ital">not</span> <span>S</span><span class="Subscript">1</span> <span>and S</span><span class="Subscript">0</span> <span>, so it only generates a “1” when S</span><span class="Subscript">1</span> <span>= “0”, S</span><span class="Subscript">0</span> <span>= “1”, and D</span><span class="Subscript">1</span> <span>= “1”. Other selector bit patterns keep it low. The</span> <span class="Ital">and</span> <span>gate that receives the D</span><span class="Subscript">2</span> <span>signal is connected to S</span><span class="Subscript">1</span> <span>and</span> <span class="Ital">not</span> <span>S</span><span class="Subscript">0</span> <span>. This gate produces a “1” only when S</span><span class="Subscript">1</span> <span>= “1”, S</span><span class="Subscript">0</span> <span>= “0”, and D</span><span class="Subscript">2</span> <span>= “1”; it generates a “0” at all other times. Finally, the</span> <span class="Ital">and</span> <span>gate for D</span><span class="Subscript">3</span> <span>is attached directly to S</span><span class="Subscript">1</span> <span>and S</span><span class="Subscript">0</span> <span>. Thus, it generates a “1” when S</span><span class="Subscript">1</span> <span>= “1”, S</span><span class="Subscript">0</span> <span>= “1”, and D</span><span class="Subscript">3</span> <span>= “1”.</span>
			</p>

			<p>
				<span>Because of the way the selector signals are routed to the various</span> <span class="Ital">and</span> <span>gates, it is impossible for more than one of them to produce a “1” at the same time. For this reason</span> <span>the results of the</span> <span class="Ital">and</span> <span>gates can be safely combined via an</span> <span class="Ital">or</span> <span>without worrying that signals from multiple data lines will be accidentally combined.</span>
			</p>

			<p>
				The four-input multiplexer can be represented by a “black box” such as the following.
			</p>

			<h1>INSERT BLACK BOX</h1>
			<p>
				(a) &nbsp;MUX transmitting input Data Channel Zero on output Channel Z
			</p>

			<h1>INSERT A</h1>
			<p>
				(b) &nbsp;MUX transmitting input Data Channel One on output Channel Z
			</p>

			<h1>INSERT B</h1>
			<h1>INSERT FIGURE 12.20</h1>

			<p>
				Figure 12.20: An illustration of the behavior of multiplexers
			</p>

			<p>
				<span>Figure 12.20 illustrates the behavior of the four-input MUX over time. The input lines and output lines are labeled with the data streams flowing down them. During the period of time illustrated in Figure 12.20(a), selector lines S</span><span class="Subscript">1</span> <span>and S</span><span class="Subscript">0</span> <span>are both held at zero, making Data Channel Zero the “active” data channel. In part (b), S</span><span class="Subscript">1</span> <span>is held at zero and S</span><span class="Subscript">0</span> <span>at one, activating Data Channel One.</span>
			</p>

			<span>While the selector lines are held steady, the current state of each of the data lines varies over time.</span> <span class="Footnote"><a href="#ftn3" id="body_ftn3">[3]</a></span> <span>&nbsp;For example, in both parts of Figure 12.20, line D</span><span class="Subscript">0</span> <span>first contains a “0”, then its value changes to “1”, then back to “0”, then to “1”, then “0”, then “1”, etc. Line D1 begins by broadcasting four consecutive “1’s” followed by four consecutive “0’s”.</span>

			<p>
				<span>Notice that when Data Channel Zero is active (S</span><span class="Subscript">1</span> <span>= “0”, S</span><span class="Subscript">0</span> <span>= “0”), its bit pattern, (“0”, “1”, “0”, “1”, “0”, “1”, “0”, “1”) is copied to the output channel. Likewise, when Data Channel One is active (S</span><span class="Subscript">1</span> <span>= “0”, S</span><span class="Subscript">0</span> <span>= “1”), its bit pattern (“1”, “1”, “1”, “1”, “0”, “0”, “0”, “0”) is copied to the output channel.</span>
			</p>

			<h1>INSERT FIGURE 12.21</h1>
			<p class="Figure">
				Figure 12.21: An implementation of a four-output demultiplexer
			</p>

			<p>
				<span>The next circuit we will look at is the demultiplexer. The demultiplexer is the exact opposite of the multiplexer. Each demultiplexer has a single data input line,</span> <span class="Ital">n</span> <span>selector input lines, and 2</span><span class="Superscript">n</span> <span>output data lines. As was the case with multiplexers, the</span> <span class="Ital">n</span> <span>selector lines are numbered from 0 to</span> <span class="Ital">n</span> <span>– 1, and the 2</span><span class="Superscript">n</span> <span>output data lines from 0 to 2</span><span class="Superscript">n</span> <span>– 1. Demultiplexers generate a copy of their input data value on the output data line specified by their selector lines. </span>
			</p>

			<p>
				<span>Demultiplexers are often referred to using their number of output lines. Figure 12.21 illustrates an implementation of a four-output demultiplexer. The value of the input data line labeled “A” is transferred to one of the output data lines, D</span><span class="Subscript">0</span> <span>through D</span><span class="Subscript">3</span> <span>, based on an interpretation of the bit pattern in S</span><span class="Subscript">1</span> <span>,S</span><span class="Subscript">0</span> <span>as two-bit unsigned binary number. For example, if S</span><span class="Subscript">1</span> <span>= “1” and S</span><span class="Subscript">0</span> <span>= “0”, corresponding to 10</span><span class="Subscript">two</span> <span>, or two, then the current state of the input line would be transferred to D</span><span class="Subscript">2</span> <span>.</span>
			</p>

			<p>
				The design of this circuit is quite similar to the one used for the decoder circuit of Section 12.3.4. The only difference is that a copy of the input data value is routed to each of the <span class="Ital">and</span> gates so that instead of simply setting the selected output line high, its value will instead be determined by the input data value.
			</p>

			<p>
				Here is a “black box” representation of the four-output demultiplexer, or DEMUX.
			</p>
			<h1>INSERT BLACK BOX</h1>
			<p>
				<span>Figure 12.22 illustrates the behavior of the four-input DEMUX over time. The input lines and output lines are labeled with the data streams flowing down them. During the period of time illustrated in Figure 12.22(a), selector line S</span><span class="Subscript">1</span> <span>is held at one and S</span><span class="Subscript">0</span> <span>is held at zero, making output Data Channel Two the “active” data channel. In part (b), S</span><span class="Subscript">1</span> <span>and S</span><span class="Subscript">0</span> <span>are both one, activating output Data Channel Three. These examples illustrate how a demultiplexer can “broadcast” an input data stream down one of many different output channels. Changing S</span><span class="Subscript">1</span> <span>,S</span><span class="Subscript">0</span> <span>switches the “broadcast” to a different output channel.</span>
			</p>

			<h1>INSERT BROADCAST</h1>
			<p>
				(a) DEMUX transmitting input Channel A on output Data Channel Two
			</p>

			<h1>INSERT A</h1>
			<p>
				(b) &nbsp;DEMUX transmitting input Channel A on output Data Channel Three
			</p>
			<h1>INSERT B</h1>

			<h1>INSERT FIGURE 12.22</h1>
			<p>
				Figure 12.22: An illustration of the behavior of demultiplexers
			</p>

			<p class="Section">
				Exercises for Section 12.3.5
			</p>

			<ol>
				<li>
					<p>
						Derive the Boolean expression for the output of the four-input multiplexer shown in Figure 12.19.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Give a Boolean expression that represents the output of an eight-input multiplexer.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Design a circuit to implement the functionality of an eight-input multiplexer.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Design a circuit to implement the functionality of an eight-output demultiplexer.&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.4 &nbsp;Sequential Circuits
			</p>

			<p>
				All of the circuits discussed up to this point have been combinational circuits whose outputs depended solely on their inputs. Such circuits do not incorporate feedback and have no “memory” of their previous state. In order to construct a general-purpose computer, circuits capable of &nbsp;“remembering” instructions, data, and the results of computations are needed.
			</p>

			<p>
				It is possible to design circuits that exhibit “memory” by incorporating feedback – in the sense that the outputs of a circuit can be made to depend not only on the circuit’s current inputs, but also on its past outputs as well. Such circuits are termed “sequential circuits”, since their output may be viewed as a function of a sequence of past inputs. Basically, sequential circuits have memory because one or more of their outputs are “fed back” to serve as input. So, the sequential circuit’s next output will, in a sense, be a function of its present inputs and its previous outputs.
			</p>

			<p>
				We will limit our study of sequential circuits to one, very important, type of circuit: the flip-flop. The term “flip-flop” is a generic term applied to devices having two stable states. The primary function of a flip-flop is to store a binary digit, “0” or “1”. Therefore a flip-flop can be used to implement the most basic unit of memory, the bit. A flip-flop is implemented as a set of logic gates that make use of feedback to remain in one of two stable states, thereby “remembering” a binary digit. There are many different types of flip-flops: R-S, D, T, and J-K. We will look at only one type, the R-S flip-flop.
			</p>

			<p class="Section">
				12.4.1 The R-S flip-flop&nbsp;
			</p>

			<p>
				<span>An R-S flip-flop can be constructed from two interconnected</span> <span class="Ital">nor</span> <span>gates. Figure 12.23 illustrates such an R-S flip-flop. As discussed in Section 12.2.4, a</span> <span class="Ital">nor</span> <span>is simply an</span> <span class="Ital">or</span> <span>gate followed by a</span> <span class="Ital">not</span> <span>gate. For clarity, Figure 12.23 shows the two</span> <span class="Ital">nor</span> <span>gates of the flip-flop as having been decomposed into their underlying</span> <span class="Ital">or</span> <span>and</span> <span class="Ital">not</span> <span>gates.</span>
			</p>

			<h1>INSERT FIGURE 12.23</h1>

			<p class="Figure">
				Figure 12.23: R-S Flip-flop
			</p>

			<h1>INSERT FIGURE 12.24</h1>

			<p class="Figure">
				Figure 12.24: An R-S flip-flop holding a “1”
			</p>

			<p>
				R-S flip-flops have two inputs and two outputs. The inputs are usually labeled R for “Reset” and S for “Set”. The outputs are traditionally labeled Q and Q, or “not Q”. Q is the complement, or opposite, of Q, so if Q is “1” then Q should be “0”, and vice versa.
			</p>

			<p>
				The Q output of the flip-flop determines its state. In other words, examining the Q output is the same as seeing what is stored in the bit. The state can be a binary “1” (Set) or a binary “0” (Reset). When a flip-flop like the R-S is in one of its states (Set or Reset), it will remain unchanged until an appropriate signal or pulse is applied to one of its input lines. The ability of a flip-flop to hold the Q output constant until a signal is given to change the value of Q is why flip-flops are considered basic memory devices.
			</p>

			<p>
				We begin our detailed analysis of the R-S flip-flop assuming that Q is initially high (“1”), and both R and S are low (“0”), as shown in Figure 12.24. Since both of the inputs to the top <span class="Ital">or</span> <span>gate are low, its output is low, and the output of the top</span> <span class="Ital">not</span> <span>gate (the Q signal) is high. This high output is fed back into the input of the bottom</span> <span class="Ital">or</span> <span>gate making its output</span> <span>high and the output of the</span> <span class="Ital">not</span>gate (the Q signal) low. This is a stable circuit. While R and S remain low, Q will remain high and Q low. The bit is thus holding a “1”.
			</p>

			<p>
				If we apply a “1” to the R (reset) input, in order to place a “0” into the bit, the following events occur. The output of the top <span class="Ital">nor</span> <span>gate (the Q signal) goes low, this is fed back to the input of the bottom</span> <span class="Ital">nor</span> <span>gate, which causes its output (the Q signal) to go high. This signal is fed back to the top</span> <span class="Ital">nor</span>gate, but since it already has another high input there is no change in the output – it remains low. This is a stable circuit, as shown in Figure 12.25. The flip-flop has been reset to “0”.
			</p>

			<h1>INSERT FIGURE 12.25</h1>

			<p class="Figure">
				Figure 12.25: An R-S flip-flop reset to “0”
			</p>

			<p>
				If the reset signal is removed (set to low), the flip-flop remains in the reset, “0”, state since there is still a “1” input to the top <span class="Ital">nor</span> gate from the Q input. This is shown in Figure 12.26. Note that this is exactly the behavior we desire. In order for the flip-flop to be useful, it must be able to “remember” that it has been reset to “0” even after the reset signal is removed.
			</p>

			<p>
				<span>Now we apply a high signal to the S (set) input, in order to set the bit to “1”. This action causes the following events to occur. The output of the bottom</span> <span class="Ital">nor</span> <span>gate becomes 0 since one of its inputs is now high. This low signal is applied as an input to the top</span> <span class="Ital">nor</span> <span>gate, where the R input is also low. The output of the top</span> <span class="Ital">nor</span> <span>is forced high, and this high output is fed back into the bottom</span> <span class="Ital">nor</span> <span>gate, which does not change its state since its other input was already high. The flip-flop has been set to “1”, as can be seen in Figure 12.27.</span>
			</p>

			<h1>INSERT FIGURE 12.26</h1>
			<p class="Figure">
				Figure 12.26: An R-S flip-flop holding a “0”
			</p>
			<h1>INSERT FIGURE 12.27</h1>

			<p class="Figure">
				Figure 12.27: An R-S flip-flop set to “1”
			</p>

			<p>
				<span>Next, we remove the set signal. In other words, we put the S input back to low. This action does not change the output of the bottom</span> <span class="Ital">nor</span> <span>gate since its other input is already high and the circuit remains in the set state, as shown in Figure 12.28. Thus, once an R-S flip-flop receives a pulse, or “1”, down its set line, it will continue to hold that “1” until a reset signal (“1” down the reset line) is received. </span>
			</p>

			<p>
				<span>Notice that state of the flip-flop shown in Figure 12.28 is identical to its original state given in Figure 12.24. They both represent the flip-flop in its “1” state, with “0” on both input lines. Comparing Figure 12.26 and Figure 12.28 illustrates another feature of flip-flops. That is that the value output by the circuit is</span> <span class="Ital">not</span> <span>solely dependent on its current inputs. When the R and S inputs are both low, “0”, the value output on the Q line depends on whether the most recent high, “1”, input was on the set line or the reset line. Figure 12.26 shows the circuit outputting a “0” on Q, because the most recent input</span> <span>operation was “reset”. Figure 12.28 shows the circuit outputting a “1”, because the most recent input operation was “set”.</span>
			</p>

			<h1>INSERT FIGURE 12.28</h1>
			<p class="Figure">
				Figure 12.28: An R-S flip-flop holding a “1”
			</p>
			<h1>INSERT FIGURE 12.29</h1>
			<p class="Figure">
				Figure 12.29: An R-S flip-flop in a stable but invalid state
			</p>

			<p>
				There is one other possible configuration of inputs we have not yet considered. What happens if both the R and S inputs are set to high at the same time – corresponding to an attempt to simultaneously store both a “0” and a “1” into a single bit? &nbsp;This is pictured in Figure 12.29. The outputs do remain constant, but the R-S flip-flop is not in a valid state because Q and Q have identical values, yet they are always supposed to be the opposite of one another.
			</p>

			<p>
				We conclude this introduction to the R-S flip-flop with its truth table.
			</p>

			<h1>INSERT TRUTH TABLE</h1>
			<p class="Section">
				Exercises for Section 12.4.1
			</p>

			<ol>
				<li>
					<p>
						Having the R and S values both be “1” at the same time <span>creates an “undesirable” state for the R-S flip-flop. What combinational circuit would help us test whether the inputs to the R-S flip-flop are “desirable” or “undesirable”?</span>&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">
				12.4.2 &nbsp;The clocked R-S flip-flop
			</p>

			<p>
				<span>A</span> <span class="Bolded">clock</span> <span>is a device that generates a signal that periodically cycles between a high state, “1”, and a low state, “0”. Clocks ensure that the operations performed by a computer proceed in an orderly manner. They do so by enabling certain operations to occur only at specific points in time.</span>
			</p>

			<p>
				<span>Clocks divide time into “cycles” that consist of two phases, a high phase and a low phase. Specifically, a</span> <span class="Bolded">clock cycle</span> <span>is defined as the interval of time beginning when the clock goes to a high state, lasting through the return to a low state, and ending with the start of the transition back to the high state again. Figure 12.30 illustrates four complete cycles of a clock. </span>
			</p>

			<p>
				Each clock cycle lasts for only a brief instant of time. The CPU of a modern PC, for example, runs at billions of clock cycles per second, or gigahertz. The clock speeds of other components, such as the system bus, are usually somewhat slower, but still in the range of hundreds of millions of clock cycles per second, or megahertz. The various operations that a computer can perform require one or more clock cycles to complete. The exact number of cycles depends upon the complexity of the particular operation.
			</p>

			<p>
				As described in the previous section, flip-flops can be used to implement the most basic unit of storage, the bit. Memory devices based on R-S flip-flops perform read operations by retrieving the contents of the Q outputs of a number of selected bits. The write operation, in turn, stores bit patterns into memory by placing 1’s on either the S (set) or R (reset) inputs of various bits.
			</p>

			<p>
				The clock ensures that these operations happen in an orderly manner. During one phase of the clock cycle (e.g., low) the contents of memory can be examined but not modified. During the opposite phase of the cycle (e.g., high) the contents of memory can be updated. This sort of timing is critical for the reliable operation of a computer, since among other things, it allows time after a “write” operation for the flip-flops to settle into their stable configurations before “read” operations can be attempted.
			</p>

			<h1>INSERT FIGURE 12.30</h1>
			<p class="Figure">
				Figure 12.30: Four cycles of a clock
			</p>
			<h1>INSERT FIGURE 12.31</h1>
			<p class="Figure">
				Figure 12.31: A clocked R-S flip-flop
			</p>

			<p>
				Figure 12.31 presents the circuit diagram of a clocked R-S flip-flop. In addition to the R (reset) and S (set) inputs, these circuits also receive the clock signal. In the clocked R-S flip-flop the Q output will be unaffected by any change in R or S as long as the clock (C) is “0” (low). That is, during the “read” phase of the clock cycle the contents of memory cannot be changed. When the clock input goes to “1” (high), designating the “write” phase of the clock cycle, the Q output will change depending upon the values of R and S.
			</p>

			<p class="Section">
				Exercises for Section 12.4.2
			</p>

			<ol>
				<li>
					<p>
						Develop a truth table for the clocked R-S flip-flop.
					</p>
				</li>
			</ol>

			<p class="Section">
				12.5 &nbsp;Design of a simple microcomputer
			</p>

			<p class="Section">
				&nbsp;
			</p>

			<p>
				In this section, we will look at how two of the higher-level components of a simple microcomputer, the ALU and main memory, can be constructed from the low-level circuits presented in sections 12.3 and 12.4. In order to have a context in which to frame this discussion, we will briefly look back at the Watson Virtual Machine of Chapter 11 – filling in some additional details concerning its construction.
			</p>

			<p class="Section">
				12.5.1 The Watson Virtual Machine revisited&nbsp;
			</p>

			<p>
				Chapter 11 introduced the Watson Virtual Machine. This machine, illustrated in Figure 11.1, consists of a main memory, CPU and data bus. A somewhat more detailed view of the machine is given in Figure 12.32.
			</p>

			<p>
				<span>The main memory of the Watson VM is composed of 256 words, each 16 bits wide. While not discussed in Chapter 11, Figure 12.32 shows that the interface to main memory (RAM) consists of two registers, the memory address register (MAD) and the memory data register (MDR). During both “read” and “write” operations, the MAR is used to hold the address of the memory location to be accessed. Since there are 256 words of memory in the Watson VM, numbered 0 – 255, the MAR is eight bits wide, enabling it to hold addresses in the range 0000 0000</span><span class="Subscript">two</span> <span>to 1111 1111</span><span class="Subscript">two</span> <span>(0 – 255). During “write” operations, the 16-bit value to be written into memory will be placed in the MDR. During “read” operations the value of the memory location to be read will be output to the MDR. Thus, the memory data register can function both in an input role (for “write” operations) and in an output role (for “read” operations). The memory address register, on the other hand, always functions in an input role – specifying the location to be accessed.</span>
			</p>

			<p>
				The majority of Figure 12.32 concerns itself with the details of the Watson Virtual Machine CPU. Special emphasis is given to illustrating the major control and data lines interconnecting the various components.
			</p>

			<p>
				In Figure 11.1 the CPU is shown as consisting of four components: a program counter, an instruction register, a collection of sixteen general-purpose registers, and four status bits. An examination of Figure 12.32 reveals that in addition to these components, there are four additional components labeled “control logic”, “ALU”, “MUX”, and “decoder”.
			</p>

			<p>
				As discussed in Chapter 11, the behavior of a computer at the machine level can be understood in terms of the five-stage instruction cycle:
			</p>

			<ol>
				<li>
					<p>
						Fetch the next instruction from memory&nbsp;
					</p>
				</li>

				<li>
					<p>
						Increment the program counter&nbsp;
					</p>
				</li>

				<li>
					<p>
						Decode the current instruction&nbsp;
					</p>
				</li>

				<li>
					<p>
						Execute the current instruction&nbsp;
					</p>
				</li>

				<li>
					<p>
						Return to step 1.&nbsp;
					</p>
				</li>
			</ol>
			<h1>INSERT FIGURE 12.32</h1>
			<p class="Figure">
				Figure 12.32: The Watson Virtual Machine &nbsp;(detailed view)
			</p>

			<p>
				The control logic, or control unit, is the component of the Watson VM responsible for implementing the instruction cycle. It does so by generating the signals necessary to direct the other components of the machine to carry out their tasks in an orderly manner. For this reason, the control unit is sometimes referred to as the “traffic cop” of the CPU. Input to the control unit is from the instruction register, since it must have access to the bit pattern that represents the instruction for it to do its job. Because of the central role played by the control unit, its outputs are connected by various data and signal lines to most of the other components of the machine.
			</p>

			<p>
				The ALU (Arithmetic / Logic Unit) is responsible for the math and logic operations performed by the machine. If the control unit is the “traffic cop”, then the ALU is the “calculator”, responsible for performing addition, subtraction, and the various logic operations. The ALU of the Watson VM receives two 16-bit input values from the general-purpose registers and one 4-bit control code from the control unit. The 16-bit values represent the operands. The control code, derived from the op-code of the current instruction, specifies which arithmetic or logic operation is to be performed on those operands. Output from the ALU is directed to a multiplexer that is responsible for routing data to the general-purpose registers. This makes sense, because the results of arithmetic and logic operations must end up in one of the registers.
			</p>

			<p>
				Taking a closer look at the multiplexer, we see that it has three 16-bit data inputs, one from the control unit, one from the ALU and one from the memory data register. There is also a two-bit selector signal sent from the control unit to the multiplexer in order to tell it which input data values should be passed on.
			</p>

			<p>
				<span>The reason for the three data inputs into the multiplexer has to do with the sources that can generate register values. Arithmetic and logic instructions, like</span> <span class="Subfigure">ADD</span> <span>, require that the registers be able to receive input from the ALU in order to place the result of the operation into the destination register. </span> <span class="Subfigure">LOAD</span> <span>instructions require that registers be able to receive data from main memory. The</span> <span class="Subfigure">LOADIMM</span> <span>instruction requires that “immediate” values, which are part of the instruction and thus located in the instruction register, be loaded into registers. The two-bit selector signal, under the direction of the control unit, specifies which of these three sources should be routed to the registers. </span>
			</p>

			<p>
				Building this multiplexer is a straightforward exercise – we simply arrange sixteen of the four-input multiplexers of Figure 12.19 in parallel. The reason for using four-input multiplexers, even though we only have three input sources, is that multiplexers only come in powers of two – two input, four input, eight input, etc. Thus one of the inputs on each of the sixteen standard four-input multiplexers will be unused. While this is may seem a tad wasteful, it won’t cause any operational difficulties.
			</p>

			<p>
				The reason for needing sixteen copies of the “standard” four-input multiplexers is that our data values are sixteen bits wide. Thus, each of the “standard” four-input multiplexers will pass only one bit of the 16-bit data value to an output line. By arranging sixteen of these “one-bit wide” multiplexers in parallel, we can build a multiplexer capable of routing all 16 bits of the selected data value simultaneously.
			</p>

			<p>
				The final component of the CPU we’ll look at is the four-input decoder, located between the control unit and the bank of general-purpose registers. The task of this decoder is to select one of the sixteen registers for access – either for receiving a value from the MUX, or for sending a register value to either main memory or the ALU. This decoder would be similar to the three-to-eight decoder of Figure 12.16, but extended to handle four input lines and sixteen output lines.
			</p>

			<p>
				In addition to the memory and CPU, the Watson VM also contains a data bus. This bus was illustrated in Figure 11.1 simply as a path connecting the CPU and memory. In Figure 12.32 the representation of the data bus is much more detailed. It is presented as a number of separate data and address lines that connect components of the CPU to the RAM. In the figure, there are two sets of 8-bit address lines, both leading into the memory address register (MAR). There are also two sets of 16-bit data lines connected to the memory data register (MAD), one set for input and one set for output.
			</p>

			<p>
				The memory location to be retrieved, and thus the address to be loaded into the memory address register can originate from two separate CPU components, the control unit or the program counter. The address comes from the program counter when the machine is fetching the next instruction from memory. The address comes from the control unit when the machine is fetching an operand, such as a variable, from memory.
			</p>

			<p>
				The input data lines leading to the memory data register originate from the block of sixteen general-purpose registers. This makes sense, since in order to store a value into memory, the value must first be in a register.
			</p>

			<p>
				Looking at the output data lines originating from the memory data register, we see that a 16-bit memory value can be transferred to either the instruction register or the multiplexer that routes values to the general-purpose registers. If the machine is performing an instruction fetch, the bit pattern being retrieved from memory represents an instruction and therefor must be sent to the instruction register. If the machine is in the process of fetching an operand, that operand should end up in one of the sixteen general-purpose registers and is thus sent to the multiplexer.
			</p>

			<p>
				The remainder of this section presents circuit-level designs for a simple ALU and memory. Even though the Watson VM is a very simple microcomputer by today’s standards, it is still much too complex for us to go through a full design of its components. Instead, the components we will look at will be even simpler. Their development, however, should convince you that computers can be constructed from the combinational and sequential circuits of section 12.3 and 12.4.
			</p>

			<p class="Section">
				12.5.2 &nbsp;The Arithmetic / Logic Unit
			</p>

			<p>
				Figure 12.33 presents a circuit that implements a very simple arithmetic / logic unit. This ALU is capable of only two operations: “add” and “ and”. Thus, instead of the 4-bit op-code used by the Watson VM, this ALU uses a single-bit op-code. The circuit has been designed in such a way that “0” will be the op-code for “add” and “1” for “and”. In order to keep the circuit simple, the operands accepted by this ALU are only two bits wide.
			</p>

			<h1>INSERT FIGURE 12.33</h1>
			<p class="Figure">
				Figure 12.33: A two-bit wide ALU capable of performing “add” and “and”
			</p>

			<p>
				Here are some statements that could be executed by this ALU, along with the results produced, and translations of each operation into English.
			</p>

			<h1>INSERT ENGLISH ALU</h1>
			<p>
				<span>The ALU contains an “addition unit” consisting of a two-bit full adder, to perform the “add” instruction; and an “ ‘and’ unit” composed of two</span> <span class="Ital">and</span> <span>gates, to perform the “and” instruction. The outputs of both of these “sub-circuits” are routed into a two-bit wide 2-input multiplexer. This multiplexer, which is constructed from two single-bit wide 2-input multiplexers, labeled MUX</span><span class="Subscript">low</span> <span>and MUX</span><span class="Subscript">high</span> <span>, passes either the result of the “add” or the result of the “and” onto the output lines. The “answer” that shows up as output depends on the value of the op-code bit. If the op-code is “0”, the results of “add” are forwarded. If the op-code is “1”, the results of “and” are forwarded.</span>
			</p>

			<p>
				An interesting thing to note about this particular ALU is that regardless of which op-code is sent to it, both the “add” and “and” operations are performed. The op-code simply determines which result is output.
			</p>

			<p class="Section">
				12.5.3 &nbsp;Random Access Memory (RAM)
			</p>

			<p>
				In Section 12.4 we talked about how a sequential device as simple as an R-S flip-flop could be used to remember one bit of data. We now develop a complete memory cell, called a binary cell, based on the flip-flop. When such a cell is selected and in “read” mode, the current value of its underlying flip-flop will be transferred to the cell’s output line. When the cell is selected and in “write” mode, an input data signal will determine the value remembered by the flip-flop. A complete circuit is shown in Figure 12.34.
			</p>

			<p>
				The fundamental design of this binary cell is based on the R-S flip-flop of Figure12.23 though there are some significant differences. To begin with, the cell has three inputs and a single output. The inputs are labeled “Select”, “Read/write”, and “Input”. The output line is labeled “Output”.
			</p>

			<h1>INSERT FIGURE 12.34</h1>

			<p class="Figure">
				Figure 12.34: A Binary cell (BC) for RAM memory
			</p>

			<p>
				<span>The “select” input is used to access the cell, either for reading or writing. When the select line is high, “1”, then a memory operation can be performed on this cell. When the select line of the binary cell is low, “0”, then the contents of the cell are not currently of interest – i.e., at the present time the cell is not being read from or written to. We can see how “select” is given this power by noting that both the inputs and the output of the underlying R-S flip-flop are routed through</span> <span class="Ital">and</span> <span>gates and that “select” is one of the inputs to each of these gates. Thus, if “select” is low, the inputs to the R-S flip-flop will stay low (meaning that its stored value will not change) and the output produced by the cell will be low (regardless of whether the actual bit held in the flip-flop is “0” or “1”).</span>
			</p>

			<p>
				The next input we’ll examine is “Read/write”. A system clock will drive this input. As was the case with the clocked R-S flip-flop of Figure 12.31, a low, “0”, will signify “read” while a high, “1”, will signify “write”. During the read phase it will not be possible to write to the cell. Likewise, during the write phase it will not be possible to read the contents of the cell.
			</p>

			<p>
				<span>Assume the cell has been selected (i.e., “select” is high signifying that a memory access operation is to be performed on this cell.) &nbsp;Furthermore, assume that the clock value on the “Read/write” line is low (forcing the “negated Read/write” to high) indicating the cell contents are to be read. In this case, the value output by the cell will depend solely on the Q value of the flip-flop. If Q is low, the cell outputs a “0”, if Q is high, the cell outputs a “1”. This is because the</span> <span class="Ital">and</span> <span>gate attached to the cell’s output line has three inputs: “select”, “negated Read/write”, and Q; and both “select” and “negated Read/write” are currently high.</span>
			</p>

			<p>
				<span>As mentioned earlier, when the cell is being read its contents cannot be modified. The reason for this is that the same low value on the “Read/write” line that allows the cell to be read, is fed into the</span> <span class="Ital">and</span> <span>gates guarding the inputs to the flip-flop. Thus during reads, the inputs to R and S are guaranteed to be low preventing the value of the flip-flop from being modified.</span>
			</p>

			<p>
				When the cell is selected and the “Read/write” line is set to high, signifying a “write” operation, the value placed into the cell will depend solely on the state of the “Input” line.
			</p>

			<p>
				<span>The reason for this is that the</span> <span class="Ital">and</span> <span>gates that guard the R and S inputs of the flip-flop will both have two of their inputs set high: the “select” and “Read/write” inputs. Thus, if “Input” is high, S (set) will receive a high and the flip-flop will store a “1”. If, on the other hand, “Input” is low, then R (reset) which receives a negated version of “Input” will go high and the flip-flop will reset to “0”. Note that having a negated version of the input line run into R is a clever idea, since it prevents the R-S flip-flop from ever entering into its invalid state. (Recall from our discussion of R-S flip-flops in Section 12.4 that if R and S are ever set to “1” at the same time the flip-flop enters a stable, but invalid state.)</span>
			</p>
			<h1>INSERT FIGURE 12.35 </h1>

			<p class="Figure">
				Figure 12.35: A Binary Cell – encapsulated view
			</p>

			<p>
				<span>It is worth mentioning that during write operations, reading is prohibited. This is easy to see, since the</span> <span class="Ital">and</span> <span>gate guarding the “Output” line receives one of its inputs from “negated Read/write” which is held low during write operations. Hence, output from the cell will always be low, “0”, during writes, regardless of the actual value on the Q line.</span>
			</p>

			<p>
				<span>Figure 12.35 contains an encapsulated view of a single binary cell. An entire random access memory (RAM) can be constructed from a large collection of binary cells, together with some address decoding circuitry. The Watson Virtual Machine includes a memory of 256 words, each 16 bits wide – much too large to be conveniently illustrated.</span> <span class="Footnote"><a href="#ftn4" id="body_ftn4">[4]</a></span> <span>&nbsp;In order to have a manageable circuit diagram, Figure 12.36 presents an implementation of a 4 x 2 RAM. Such a RAM module has four separate “words” of memory, each two bits wide.</span>
			</p>

			<p>
				A word of storage will consist of two binary cells arranged in such a way that both bits can be accessed simultaneously. Because the memory consists of four of these words, a total of eight binary cells will be used. These cells will be laid out according to a four row by two column grid pattern, where each row of the grid represents one word.
			</p>

			<p>
				<span>Examining the inputs to the memory unit, we see that there are two input data lines at the top of the diagram (D</span><span class="Subscript">1</span> <span>and D</span><span class="Subscript">0</span> <span>), representing the two bits of the number to be written. One of these bits will be the high-order data bit and one the low. The signal from the high-order data input line is fed to the high-order bit of every word. Likewise, the low-order data input signal is fed to the low-order bit of every word.</span>
			</p>

			<p>
				<span>On the left side of the circuit diagram, a two-bit address (A</span><span class="Subscript">1</span> <span>and A</span><span class="Subscript">0</span> <span>) is input. This address is fed into a two-to-four decoder that generates a high signal down the data line corresponding to the word of memory to be accessed (either read or written).  The decoder also accepts an “enable” input. This input essentially tells the decoder whether the bit pattern currently on the input address lines is a valid memory address that is to be decoded, or whether the circuit should just ignore this bit pattern for the moment.</span>
			</p>

			<h1>INSERT FIGURE 12.36</h1>
			<p class="Figure">
				Figure 12.36: A 4 x 2 RAM memory
			</p>

			<p>
				The final input is the clock signal that the memory unit receives via the read/write line. Note that this signal is propagated to every binary cell in the entire RAM, allowing the memory unit to either read from or write to any of the binary cells.
			</p>

			<p>
				<span>Two output lines are visible at the bottom of the circuit (Z</span><span class="Subscript">1</span> <span>and Z</span><span class="Subscript">0</span> <span>); one for the high-order bit of the number to be output, one for the low-order bit. As you can see, the output lines from each of the four binary cells making up a column are fed into a multi-input</span> <span class="Ital">or</span> <span>gate that is tied to the output line for that column. So, if any of the binary cells in a column produces a “1”, then that column’s output line will produce a “1” as well. Due to the presence of the address decoder, however, we can be sure that only one row, and thus only one bit per column, can be accessed (either read or written) at any point in time.</span>
			</p>

			<p>
				We now come to the close of our discussion concerning the implementation of main memory, and thus to the end of this book’s material on computer “hardware”. As I am sure you can appreciate, we have just scratched the surface of this fascinating field. However, my hope is that this brief introduction to digital logic has convinced you that computers can be completely understood in terms of large networks of very simple logic gates that are interconnected in complex patterns.
			</p>

			<p class="Section">
				Exercises for Section 12.5
			</p>

			<ol>
				<li>
					<p>
						Draw the decoder circuit required in Figure 12.36. All output lines should be low, “0”, when the “enable” line is low. When “enable” is high this decoder functions like the normal 2-to-4 decoders discussed in Section 12.3.&nbsp;
					</p>
				</li>

				<li>
					<p>
						Assume that the circuit in Figure 12.36 is built using only two-input<span class="Ital">and</span>gates, two-input<span class="Ital">or</span>gates, and single-input <span class="Ital">not</span> <span>gates. In other words, each four-input</span> <span class="Ital">or</span> <span>gate shown at the bottom would require 3 two-input</span> <span class="Ital">or</span> <span>gates to implement. Calculate the number of gates of each type required to fully implement this 4 x 2 RAM.</span>&nbsp;
					</p>
				</li>

				<li>
					<p>
						Figure 12.36 is a simplified circuit that uses only eight binary cells (BCs). How many BCs will be required to construct the RAM of the Watson Virtual Machine, which has 256 words of memory each 16 bits wide?&nbsp;
					</p>
				</li>
			</ol>

			<p class="Section">Footnotes</p>
			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" href="#body_ftn1" id="ftn1">[1]</a></span> <span>&nbsp;</span>The fully-parenthesized Boolean expression for this implementation of the four-input <span class="Ital">or</span> is
			</p>

			<p class="Footnote">
				Z = ((A+B)+(C+D)). There are other possible implementations of this gate. For example, the circuit defined by the Boolean expression Z = (((A+B)+C)+D).
			</p>

			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" href="#body_ftn2" id="ftn2">[2]</a></span> <span>&nbsp;</span>Rhymes with “sucks”.
			</p>

			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" href="#body_ftn3" id="ftn3">[3]</a></span> <span>&nbsp;</span>Signals that vary over time require the presence of a “system clock”. As we will see later in this chapter, computers incorporate clocks to coordinate the actions of all of their various circuits and the data that flows through them.
			</p>

			<p class="Footnote">
				<span class="footnodeNumber"><a class="Footnote" href="#body_ftn4" id="ftn4">[4]</a></span> <span>&nbsp;</span>Though at 0.5 K bytes it is pathetically small by today’s standards. In fact, about a million times smaller than the 500 Meg machine I am writing this book on.
			</p>
			<!-- End main content -->

			<nav>
				<p>
					--
				</p>
				<p>
					<a href="index.html">Home</a>
				</p>
				<p>
					<a href="mailto:someone@example.com?Subject=Hello%20again" target="_top"> Contact</a>
				</p>
			</nav>

			<div>

			</div>

			<footer>
				<p>
					&copy; Copyright  by Burt
				</p>
			</footer>
			
			<script src="js/Controller.js"></script>
		<script src="js/AndGate.js"></script>
		<script src="js/OrGate.js"></script>
		<script src="js/NotGate.js"></script>
		<script src="js/Connector.js"></script>
		<script src="js/InputNode.js"></script>
		<script src="js/OutputNode.js"></script>
		<script src="js/PopupMenu.js"></script>
		<script src="js/Figures.js"></script>
		<script src="js/TruthTable.js"></script>
		<script src="js/Setup.js"></script>
		<script src="js/DigitalLogicFigure.js"></script>
		
		<script>
			var figure1 = new DigitalLogicFigure("container1", 18, 600, 250);
			//var figure2 = new DigitalLogicFigure("container2",  2, window.innerWidth, window.innerHeight);
		</script>
		</div>
	</body>
</html>
